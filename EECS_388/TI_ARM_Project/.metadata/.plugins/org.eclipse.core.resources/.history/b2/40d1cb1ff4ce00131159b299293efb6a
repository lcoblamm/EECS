//*****************************************************************************
//
//	Call assembly language subroutine
//
//		Author: 		Lynne Lammers
//		Organization:	KU/EECS/EECS 388
//		Date:			2014-04-21
//		Version:		1.0
//
//		Purpose:		Call assembly language subroutine and check result
//
//		Notes: Adapted from Task_ASMCompute by Gary J. Minden
//
//*****************************************************************************
// Edited by Brad Torrence 2014-4-21

#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_types.h"

#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/gpio.h"
#include "Drivers/uartstdio.h"
#include "driverlib/timer.h"

#include "FreeRTOS.h"
#include "task.h"

#include "stdio.h"


extern void Task_IntTimer( void *pvParameters );
long int TimerCount;

//*****************************************************************************
//
//	Task initialization
//
//*****************************************************************************
void Task_IntTimer(void *pvParameters) {
	TimerCount = 0;

	unsigned short centiseconds = 0;
	unsigned short seconds = 0;
	unsigned short minutes = 0;
	unsigned short hours = 0;
	unsigned long TimerStatus1;

	// enable timer_0
	SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);

	// configure timer as 16-bit periodic
	TimerConfigure(TIMER0_BASE, TIMER_CFG_A_PERIODIC);

	// set up timer prescaler to be 160 nS / tick
	TimerPrescaleSet(TIMER0_BASE, TIMER_A, 7);

	// set load value to 62500 (for 10 ms)
	TimerLoadSet(TIMER0_BASE, TIMER_A, 62500);

	// enable timer 0A
	TimerEnable(TIMER0_BASE, TIMER_A);

    while (1) {

    	// wait for interrupt
    	while (((TimerStatus1 = TimerIntStatus(TIMER0_BASE,0)) & TIMER_TIMA_TIMEOUT) == 0) {
    		// wait
    	}

    	// clear interrupt
    	TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    	TimerCount++;

    	// update time appropriately
    	if (centiseconds == 99) {
    		centiseconds = 0;
    		if (seconds == 59) {
    			seconds = 0;
    			if (minutes == 59) {
    				minutes = 0;
    				hours++;
    			}
    			else {
    				minutes++;
    			}
    		}
    		else {
    			seconds++;
    		}
    	}
    	else {
    		centiseconds++;
    	}

    	UARTprintf("%d:%d:%d.%d\n", hours, minutes, seconds, centiseconds);
    }
}

